// autogenerated from core.n
// do not edit
const char* core_source = "pub class BadArgumentTypeException {\n"
"    priv:\n"
"        msg\n"
"    pub:\n"
"        new(x) {\n"
"            msg = x\n"
"        }\n"
"\n"
"        fn str() {\n"
"            ret msg\n"
"        }\n"
"}\n"
"\n"
"pub class RuntimeException {\n"
"    priv:\n"
"        msg\n"
"    pub:\n"
"        new(x) {\n"
"            msg = x\n"
"        }\n"
"\n"
"        fn str() {\n"
"            ret msg\n"
"        }\n"
"}\n"
"\n"
"pub class array {\n"
"    priv:\n"
"        items, size, capacity\n"
"\n"
"        // this will be called only once\n"
"        // during initialization, so it\n"
"        // should not be much of a problem\n"
"        fn nearestPowerOfTwo(x) {\n"
"            res = 1\n"
"            while(res < x) {\n"
"                res = res * 2\n"
"            }\n"
"            ret res\n"
"        }\n"
"    pub:\n"
"        new() {\n"
"            size = 0\n"
"            capacity = 1\n"
"            items = __next_array_allocate(1)\n"
"        }\n"
"\n"
"        new(x) {\n"
"            if(!is_same_type(x, 2) or !x.is_int() or x < 0) {\n"
"                throw RuntimeException(\"Array size should be a positive integer!\")\n"
"            }\n"
"            size = 0\n"
"            capacity = nearestPowerOfTwo(x)\n"
"            items = __next_array_allocate(capacity)\n"
"        }\n"
"\n"
"        new(x, i) {\n"
"            if(!__next_array_validate_item(i)) {\n"
"                throw RuntimeException(\"Invalid items!\")\n"
"            }\n"
"            if(!is_same_type(x, 2) or !x.is_int() or x < 0) {\n"
"                throw RuntimeException(\"Array size should be a positive integer!\")\n"
"            }\n"
"            capacity = nearestPowerOfTwo(x)\n"
"            items = i\n"
"            if(capacity != x) {\n"
"                items = __next_array_reallocate(items, x, capacity)\n"
"            }\n"
"            size = x\n"
"        }\n"
"\n"
"        fn insert(val) {\n"
"            size++\n"
"            if(size == capacity) {\n"
"                // since there might be reallocations,\n"
"                // items might point to invalid address\n"
"                // if not reassigned\n"
"                items = __next_array_reallocate(items, capacity, capacity * 2)\n"
"                capacity = capacity * 2\n"
"            }\n"
"            // it might be implemented in the interpreter\n"
"            this[size - 1] = val\n"
"            ret val\n"
"        }\n"
"\n"
"        op [](pos, val) {\n"
"            if(!is_same_type(pos, 2) or !pos.is_int()) {\n"
"                throw RuntimeException(\"Array index should be an integer!\")\n"
"            }\n"
"            else if(pos > size or -pos > size) {\n"
"                throw RuntimeException(\"Invalid array index!\")\n"
"            }\n"
"            // if pos is negative, item to be accessed is\n"
"            // from the end of the array\n"
"            if(pos < 0) {\n"
"                pos = size + pos\n"
"            } else if(pos == size) {\n"
"                ret insert(val)\n"
"            }\n"
"            ret __next_array_set(items, pos, val)\n"
"        }\n"
"\n"
"        op [](pos) {\n"
"            if(!is_same_type(pos, 2) or !pos.is_int()) {\n"
"                throw RuntimeException(\"Array index should be an integer!\")\n"
"            }\n"
"            else if(pos >= size or -pos > size) {\n"
"                throw RuntimeException(\"Invalid array index!\")\n"
"            }\n"
"            // if pos is negative, item to be accessed is\n"
"            // from the end of the array\n"
"            if(pos < 0) {\n"
"                pos = size + pos\n"
"            }\n"
"            ret __next_array_get(items, pos)\n"
"        }\n"
"\n"
"        fn size() { ret size }\n"
"}\n"
"\n"
"pub class hashmap {\n"
"    priv:\n"
"        map\n"
"\n"
"        fn get_hash(v) {\n"
"            if(!__next_is_hashable(v)) {\n"
"                finalhash = v\n"
"                while(!__next_is_hashable(finalhash)) {\n"
"                    if(__next_has_method(finalhash, \"hash()\")) {\n"
"                        finalhash = finalhash.hash()\n"
"                    } else {\n"
"                        throw RuntimeException(\"Method hash() not found in the object!\")\n"
"                    }\n"
"                }\n"
"                ret finalhash\n"
"            }\n"
"            ret v\n"
"        }\n"
"    pub:\n"
"        new() {\n"
"            map = __next_hashmap_new()\n"
"        }\n"
"\n"
"        fn has(v) {\n"
"            hash = get_hash(v)\n"
"            ret __next_hashmap_has_key(map, hash)\n"
"        }\n"
"\n"
"        fn remove(v) {\n"
"            hash = get_hash(v)\n"
"            ret __next_hashmap_remove(map, hash)\n"
"        }\n"
"\n"
"        fn size() {\n"
"            ret __next_hashmap_size(map)\n"
"        }\n"
"\n"
"        fn values() {\n"
"            s = size()\n"
"            i = __next_hashmap_values(map)\n"
"            ret array(s, i)\n"
"        }\n"
"\n"
"        fn keys() {\n"
"            s = size()\n"
"            i = __next_hashmap_keys(map)\n"
"            ret array(s, i)\n"
"        }\n"
"\n"
"        op [](key) {\n"
"            hash = get_hash(key)\n"
"            ret __next_hashmap_get(map, hash)\n"
"        }\n"
"\n"
"        op [](key, value) {\n"
"            hash = get_hash(key)\n"
"            ret __next_hashmap_set(map, hash, value)\n"
"        }\n"
"}\n"
"\n"
"pub class range{\n"
"    priv:\n"
"        from, to, step, pos\n"
"    pub:\n"
"        new(x) {\n"
"            if(!is_same_type(x, 2) or !x.is_int()) {\n"
"                throw RuntimeException(\"Range upto must be an integer!\")\n"
"            }\n"
"            from = 0\n"
"            to = x\n"
"            step = 1\n"
"            pos = 0\n"
"        }\n"
"\n"
"        new(x, y) {\n"
"            if(!is_same_type(x, 2) or !x.is_int()) {\n"
"                throw RuntimeException(\"Range from must be an integer!\")\n"
"            }\n"
"            if(!is_same_type(y, 2) or !y.is_int()) {\n"
"                throw RuntimeException(\"Range upto must be an integer!\")\n"
"            }\n"
"            from = x\n"
"            to = y\n"
"            step = 1\n"
"            pos = x\n"
"        }\n"
"\n"
"        new(x, y, z) {\n"
"            if(!is_same_type(x, 2) or !x.is_int()) {\n"
"                throw RuntimeException(\"Range from must be an integer!\")\n"
"            }\n"
"            if(!is_same_type(y, 2) or !y.is_int()) {\n"
"                throw RuntimeException(\"Range upto must be an integer!\")\n"
"            }\n"
"            if(!is_same_type(z, 2) or !z.is_int() or z < 0) {\n"
"                throw RuntimeException(\"Range step must be an integer!\")\n"
"            }\n"
"            from = x\n"
"            to = y\n"
"            step = z\n"
"            pos = x\n"
"        }\n"
"\n"
"        fn next() {\n"
"            if(pos < to) {\n"
"                pos = pos + step\n"
"            }\n"
"            ret pos\n"
"        }\n"
"\n"
"        fn from() {\n"
"            ret from\n"
"        }\n"
"\n"
"        fn to() {\n"
"            ret to\n"
"        }\n"
"\n"
"        fn step() {\n"
"            ret step\n"
"        }\n"
"\n"
"        fn includes(x) {\n"
"            if(x >= from and x < to){\n"
"                ret true\n"
"            }\n"
"            ret false\n"
"        }\n"
"}\n"
;