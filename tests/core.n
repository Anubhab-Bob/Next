pub class BadArgumentTypeException {
    priv:
        msg
    pub:
        new(x) {
            msg = x
        }

        fn str() {
            ret msg
        }
}

pub class RuntimeException {
    priv:
        msg
    pub:
        new(x) {
            msg = x
        }

        fn str() {
            ret msg
        }
}

pub class array {
    priv:
        items, size, capacity

        // this will be called only once
        // during initialization, so it
        // should not be much of a problem
        fn nearestPowerOfTwo(x) {
            res = 1
            while(res < x) {
                res = res * 2
            }
            ret res
        }
    pub:
        new() {
            size = 0
            capacity = 1
            items = __next_array_allocate(1)
        }

        new(x) {
            if(!is_same_type(x, 2) or !x.is_int() or x < 0) {
                throw RuntimeException("Array size should be a positive integer!")
            }
            size = 0
            capacity = nearestPowerOfTwo(x)
            items = __next_array_allocate(capacity)
        }

        new(x, i) {
            if(!__next_array_validate_item(i)) {
                throw RuntimeException("Invalid items!")
            }
            if(!is_same_type(x, 2) or !x.is_int() or x < 0) {
                throw RuntimeException("Array size should be a positive integer!")
            }
            capacity = nearestPowerOfTwo(x)
            items = i
            if(capacity != x) {
                items = __next_array_reallocate(items, x, capacity)
            }
            size = x
        }

        fn insert(val) {
            size++
            if(size == capacity) {
                // since there might be reallocations,
                // items might point to invalid address
                // if not reassigned
                items = __next_array_reallocate(items, capacity, capacity * 2)
                capacity = capacity * 2
            }
            // it might be implemented in the interpreter
            this[size - 1] = val
            ret val
        }

        op [](pos, val) {
            if(!is_same_type(pos, 2) or !pos.is_int()) {
                throw RuntimeException("Array index should be an integer!")
            }
            else if(pos > size or -pos > size) {
                throw RuntimeException("Invalid array index!")
            }
            // if pos is negative, item to be accessed is
            // from the end of the array
            if(pos < 0) {
                pos = size + pos
            } else if(pos == size) {
                ret insert(val)
            }
            ret __next_array_set(items, pos, val)
        }

        op [](pos) {
            if(!is_same_type(pos, 2) or !pos.is_int()) {
                throw RuntimeException("Array index should be an integer!")
            }
            else if(pos >= size or -pos > size) {
                throw RuntimeException("Invalid array index!")
            }
            // if pos is negative, item to be accessed is
            // from the end of the array
            if(pos < 0) {
                pos = size + pos
            }
            ret __next_array_get(items, pos)
        }

        fn size() { ret size }
}

pub class hashmap {
    priv:
        map

        fn get_hash(v) {
            if(!__next_is_hashable(v)) {
                finalhash = v
                while(!__next_is_hashable(finalhash)) {
                    if(__next_has_method(finalhash, "hash()")) {
                        finalhash = finalhash.hash()
                    } else {
                        throw RuntimeException("Method hash() not found in the object!")
                    }
                }
                ret finalhash
            }
            ret v
        }
    pub:
        new() {
            map = __next_hashmap_new()
        }

        fn has(v) {
            hash = get_hash(v)
            ret __next_hashmap_has_key(map, hash)
        }

        fn remove(v) {
            hash = get_hash(v)
            ret __next_hashmap_remove(map, hash)
        }

        fn size() {
            ret __next_hashmap_size(map)
        }

        fn values() {
            s = size()
            i = __next_hashmap_values(map)
            ret array(s, i)
        }

        fn keys() {
            s = size()
            i = __next_hashmap_keys(map)
            ret array(s, i)
        }

        op [](key) {
            hash = get_hash(key)
            ret __next_hashmap_get(map, hash)
        }

        op [](key, value) {
            hash = get_hash(key)
            ret __next_hashmap_set(map, hash, value)
        }
}
